from collections import defaultdict
from operator import length_hint
from typing import Dict, List, Tuple

from dzn.dzn_generation import SMSgreedy
from pandas.io.common import uses_relative


from sfs_generator.asm_block import AsmBlock
import sfs_generator.opcodes as opcodes
from smt_encoding import instructions
from split_stack_calculator.dag import DAG

'''
    Split calculator is responable of calculating the best position for splitting a block. 
    The split position can be calculated in two ways, in the places where the stack is of minimum size 
    or the place where the dag generated by the dependencies of the instructions can be splitted cutting the least amount of edges
'''
class Split_calculator:
    min_split_point_candidate: List[int] = []

    split_point = ""

    def calculate_minstack_split(self, block:AsmBlock):

        stack_size = block.source_stack

        quart = block.length / 3
        lower_instr_num_bound = quart
        upper_instr_num_bound = quart * 2
        
        min_stack_size = 1024
        min_instr_number = 0
        for instr_number, instr in enumerate(block.instructions):

            bytecode_info = opcodes.get_opcode(instr.disasm)
            stack_size = stack_size - bytecode_info[1] + bytecode_info[2]

            if (lower_instr_num_bound < instr_number < upper_instr_num_bound and stack_size <= min_stack_size):
                min_stack_size = stack_size 
                min_instr_number = instr_number 

        self.min_split_point_candidate.append(min_instr_number)
        

        return min_stack_size, min_instr_number

    def calculate_dao_split(self, sfs_block: Dict) -> None:

        original_code_with_ids, length = self.parse_original_instr(sfs_block["original_instrs"], sfs_block["user_instrs"], sfs_block["src_ws"], sfs_block["tgt_ws"])

        if length < 10:
            return


        if original_code_with_ids == []:
            block = self.min_split_point_candidate[-1]
            print(f"splittocsv: {block.min_pos};{block.length}")
            print("no dag split found")
            return

        dag = DAG(sfs_block["instr_dependencies"], original_code_with_ids)




        quart = length/3
        min_pos_block = quart
        max_pos_block = quart * 2

        min_size = 1024
        min_pos = None

        for instr in dag.reverse:
            if (dag.id_to_pos[instr][0][0] > min_pos_block and dag.id_to_pos[instr][0][0] < max_pos_block and dag.id_to_pos[instr][0][1] < min_size):
                min_pos = dag.id_to_pos[instr][0][0]
                min_size = dag.id_to_pos[instr][0][1]

        
        print(f"min_pos: {min_pos}, min_size: {min_size}")
        self.split_point = f"splittocsv: {min_pos};{length}"

    def calculate_extended_dao_split(self, sfs_block: Dict) -> None:

        original_code_with_ids, length = self.parse_original_instr(sfs_block["original_instrs"], sfs_block["user_instrs"], sfs_block["src_ws"], sfs_block["tgt_ws"])


        if length < 10:
            return


        if original_code_with_ids == []:
            block = self.min_split_point_candidate[-1]
            print(f"splittocsv: {block.min_pos};{block.length}")
            print("no dag split found")
            return

        dag = DAG(sfs_block["instr_dependencies"], original_code_with_ids, extended=True)


        id_to_pos = dag.id_to_pos


        quart = length/3
        min_pos_block = quart
        max_pos_block = quart * 2

        min_size = 1024
        min_pos = None

        for instr in dag.reverse:
            if (id_to_pos[instr][0] > min_pos_block and id_to_pos[instr][0] < max_pos_block and id_to_pos[instr][1] < min_size):
                min_pos = id_to_pos[instr][0]
                min_size = id_to_pos[instr][1]


        print(f"min_pos: {min_pos}, min_size: {min_size}")
        self.split_point = f"splittocsv: {min_pos};{length}"

    def parse_original_instr(self, original_instr: str, user_instr: List[Dict], stack: List[str], final_stack: List[str], code_with_ids_and_pos_size=[], pos=0) -> Tuple[List[Tuple[str, int, int]], int]:

        original_instr_splitted = original_instr.split(" ")
        stack = stack.copy()

        user_instr_dict = defaultdict(list)

        for instr in user_instr:
            user_instr_dict[instr["disasm"]].append(instr)

        for i, word in enumerate(original_instr_splitted):
            if word[0].isdigit():
                continue


            if word.startswith("PUSH0"):
                if "PUSH0" in user_instr_dict.keys():
                    push0 = user_instr_dict["PUSH0"][0]
                    code_with_ids_and_pos_size.append((push0["id"], pos, len(stack)))
                    stack = push0["outpt_sk"] + stack
                else:
                    stack = ["none"] + stack

            elif word.startswith("PUSH") and "[" in original_instr_splitted[i + 1]: # [tag] or any of its derivated values ([$], #[$]...)
                value = int(original_instr_splitted[i + 2], 10)
                for push in user_instr_dict[f"PUSH {original_instr_splitted[i + 1]}"]:
                    if push["value"][0] == value:
                        code_with_ids_and_pos_size.append((push["id"], pos, len(stack)))
                        stack = push["outpt_sk"] + stack


            elif word.startswith("PUSH") and "data" in original_instr_splitted[i + 1]: # [tag] or any of its derivated values ([$], #[$]...)
                value = int(original_instr_splitted[i + 2], 16)
                for push in user_instr_dict[f"PUSH {original_instr_splitted[i + 1]}"]:
                    if push["value"][0] == value:
                        code_with_ids_and_pos_size.append((push["id"], pos, len(stack)))
                        stack = push["outpt_sk"] + stack

            elif word.startswith("PUSH") and len(word) < 8:
                value = int(original_instr_splitted[i + 1], 16)

                if "PUSH" not in user_instr_dict.keys():
                    return [], 0
                
                for push in user_instr_dict["PUSH"]:
                    if push["value"][0] == value:
                        code_with_ids_and_pos_size.append((push["id"], pos, len(stack)))
                        stack = push["outpt_sk"] + stack


            elif word.startswith("KECCAK256"):
                for kw in user_instr_dict[word]:
                    kw_input = kw["inpt_sk"] 
                    st_input = stack[:len(kw["inpt_sk"])]
                    if kw_input == st_input:

                        original_pos = pos
                        original_code_with_ids_and_pos_size = code_with_ids_and_pos_size.copy()
                        original_stack = stack.copy()


                        code_with_ids_and_pos_size.append((kw["id"], pos, len(stack)))
                        stack = stack[len(kw["inpt_sk"]):]
                        stack = kw["outpt_sk"] + stack


                        backtracking, pos = self.parse_original_instr(original_instr[len(" ".join(original_instr_splitted[0:i + 1])) + 1:],user_instr, stack, final_stack, code_with_ids_and_pos_size, pos)


                        if len(backtracking) != 0:
                            return backtracking, pos

                        stack = original_stack
                        pos = original_pos
                        code_with_ids_and_pos_size = original_code_with_ids_and_pos_size


            elif word.startswith("SWAP"):
                value = int(word.replace("SWAP", ""))
                stack[0], stack[value] = stack[value], stack[0]

            elif word.startswith("DUP"):
                value = int(word.replace("DUP", ""))-1
                stack = [stack[value]] + stack

            elif word.startswith("POP"):
                stack = stack[1:]


            else:
                temp_stack = stack.copy()
                for kw in user_instr_dict[word]:
                    if kw["commutative"]:
                        kw_input = set(kw["inpt_sk"])
                        st_input = set(stack[:len(kw["inpt_sk"])])
                    else:
                        kw_input = kw["inpt_sk"] 
                        st_input = stack[:len(kw["inpt_sk"])]

                    if kw_input == st_input:
                        code_with_ids_and_pos_size.append((kw["id"], pos, len(temp_stack)))
                        temp_stack = temp_stack[len(kw["inpt_sk"]):]
                        temp_stack = kw["outpt_sk"] + temp_stack

                stack = temp_stack

            pos += 1
        
        if stack == final_stack:
            return code_with_ids_and_pos_size, pos
        else:
            return [], pos


    def __str__(self) -> str:
        return f"min: {self.min_split_point_candidate}, dao:"

    def print_split_point(self):
        if self.split_point == "":
            block = self.min_split_point_candidate[-1]
            print(f"splittocsv: {block.min_pos};{block.length}")

        else:
            print(self.split_point)
