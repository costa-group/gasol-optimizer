from collections import defaultdict
from typing import Dict, List, Tuple

from numpy._core.defchararray import isdigit

from split_stack_calculator.dag import DAG

class Stack_split:
    block_id: str
    length: int
    min_pos: int | None
    min_size: int
    min_pos_block: int
    max_pos_block: int

    def __init__(self, block_id, length, input_stack) -> None:
        self.block_id = block_id
        self.length = length
        self.input_stack = input_stack

        quart = length/3
        self.min_pos_block = quart
        self.max_pos_block = quart * 2
        
        self.min_size = 1024
        self.min_pos = None

        print(f"min_pos: {self.min_pos_block} max_pos: {self.max_pos_block}")


    def update_split_candidate(self, new_pos, new_size) -> None:
        if (new_pos > self.min_pos_block and new_pos < self.max_pos_block and new_size < self.min_size):
            self.min_size = new_size 
            self.min_pos = new_pos 
    
    def __str__(self) -> str:
        return f"id: {self.block_id}, len: {self.length}, min_size: {self.min_size}, min_pos: {self.min_pos}"


    def __repr__(self) -> str:
        return f"id: {self.block_id}, len: {self.length}, min_size: {self.min_size}, min_pos: {self.min_pos}"



class Dao_split:
    block_id: str
    length: int
    min_pos: int | None
    min_size: int
    min_pos_block: int
    max_pos_block: int

    def __init__(self, block_id, length, input_stack) -> None:
        self.block_id = block_id
        self.length = length
        self.input_stack = input_stack

        quart = length/3
        self.min_pos_block = quart
        self.max_pos_block = quart * 2
        
        self.min_size = 1024
        self.min_pos = None

        print(f"min_pos: {self.min_pos_block} max_pos: {self.max_pos_block}")


    def update_split_candidate(self, new_pos, new_size) -> None:
        if (new_pos > self.min_pos_block and new_pos < self.max_pos_block and new_size < self.min_size):
            self.min_size = new_size 
            self.min_pos = new_pos 
    
    def __str__(self) -> str:
        return f"id: {self.block_id}, len: {self.length}, min_size: {self.min_size}, min_pos: {self.min_pos}"


    def __repr__(self) -> str:
        return f"id: {self.block_id}, len: {self.length}, min_size: {self.min_size}, min_pos: {self.min_pos}"

'''
    Split calculator is responable of calculating the best position for splitting a block. 
    The split position can be calculated in two ways, in the places where the stack is of minimum size 
    or the place where the dag generated by the dependencies of the instructions can be splitted cutting the least amount of edges
'''
class Split_calculator:
    min_split_point_candidate: List[Stack_split] = []
    dag_split_point_candidate: List[Dao_split] = []

    def update_split_block(self, block: Stack_split, new_pos, new_size) -> None:
        if block.block_id not in self.min_split_point_candidate:
            block.update_split_candidate(new_pos, new_size)

    def finish_stack_split(self, block: Stack_split):
        if block.length > 10 and block.min_pos and block.block_id not in self.min_split_point_candidate: 
            self.min_split_point_candidate.append(block)
            print(f"Minimal candidate in format block: {block}")
            print(f"splittocsv: {block.min_pos};{block.length}")

    def calculate_dao_split(self, sfs_block: Dict) -> None:


        original_code_with_ids = self.parse_original_instr(sfs_block["original_instrs"], sfs_block["user_instrs"], sfs_block["src_ws"])

        print(original_code_with_ids)

        id_to_pos = defaultdict(list)

        for id, pos, siz in original_code_with_ids:
            id_to_pos[id].append((pos, siz))

        print(id_to_pos)

        dag = DAG(sfs_block["instr_dependencies"])

        


    def parse_original_instr(self, original_instr: str, user_instr: List[Dict], stack: List[str]) -> List[Tuple[str, int, int]]:
        original_instr_splitted = original_instr.split(" ")
        stack = stack.copy()
        code_with_ids_and_pos_size: List[Tuple[str, int, int]] = []

        user_instr_dict = defaultdict(list)

        for instr in user_instr:
            user_instr_dict[instr["disasm"]].append(instr)

        pos = 0

        for i, word in enumerate(original_instr_splitted):
            if word[0].isdigit():
                continue

            if word.startswith("PUSH"):
                value = int(original_instr_splitted[i + 1], 16)
                
                for push in user_instr_dict["PUSH"]:
                    if push["value"][0] == value:
                        code_with_ids_and_pos_size.append((push["id"], pos, len(stack)))
                        stack = push["outpt_sk"] + stack

            elif word.startswith("SWAP"):
                value = int(word.replace("SWAP", ""))
                stack[0], stack[value] = stack[value], stack[0]

            elif word.startswith("DUP"):
                value = int(word.replace("DUP", ""))-1
                stack = [stack[value]] + stack

            else:
                for kw in user_instr_dict[word]:
                    if kw["commutative"]:
                        kw_input = set(kw["inpt_sk"])
                        st_input = set(stack[:len(kw["inpt_sk"])])
                    else:
                        kw_input = kw["inpt_sk"] 
                        st_input = stack[:len(kw["inpt_sk"])]

                    if kw_input == st_input:
                        code_with_ids_and_pos_size.append((kw["id"], pos, len(stack)))
                        stack = stack[len(kw["inpt_sk"]):]
                        stack = kw["outpt_sk"] + stack

            pos += 1
        return code_with_ids_and_pos_size


    def __str__(self) -> str:
        return f"min: {self.min_split_point_candidate}, dao: {self.dag_split_point_candidate}"
