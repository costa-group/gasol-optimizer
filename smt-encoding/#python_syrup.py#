#!/usr/bin/env python3

from typing import TextIO
from superoptimization_enconding import generate_smtlib_encoding
from utils_bckend import add_bars_to_string
import json
import argparse
from encoding_files import initialize_dir_and_streams

costabs_path = "/tmp/costabs/"


def parse_data(json_path):
    with open(json_path) as path:
        data = json.load(path)

    # Note that b0 can be either max_progr_len
    # or init_progr_len
    # b0 = data['max_progr_len']
    b0 = data['init_progr_len']

    bs = data['max_sk_sz']
    user_instr = data['user_instrs']

    for instr in user_instr:
        instr['outpt_sk'] = list(map(add_bars_to_string, instr['outpt_sk']))
        instr['inpt_sk'] = list(map(add_bars_to_string, instr['inpt_sk']))

    initial_stack = list(map(add_bars_to_string, data['src_ws']))
    final_stack = list(map(add_bars_to_string, data['tgt_ws']))
    variables = list(map(add_bars_to_string, data['vars']))
    return b0, bs, user_instr, variables, initial_stack, final_stack


#Executes the smt encoding generator from the main script
def execute_syrup_backend(args_i,json_file = None):
    
    if json_file:
        json_path = json_file
    else:
        json_path = args_i.source

    path = costabs_path
    solver = args_i.solver

    es = initialize_dir_and_streams(path,solver,json_path)

    b0, bs, user_instr, variables, initial_stack, final_stack = parse_data(json_path)
    flags = {'at-most': args_i.at_most, 'pushed-at-least': args_i.pushed_once, 'instruction-order': False,
             'no-output-before-pop': False}
    additional_info = {'tout': args_i.tout, 'solver': args_i.solver}

    generate_smtlib_encoding(b0, bs, user_instr, variables, initial_stack, final_stack, flags, additional_info)

    es.close()

if __name__ == "__main__":
    ap = argparse.ArgumentParser(description='Backend of syrup tool')
    ap.add_argument('json_path', help='Path to json file that contains the SFS')
    ap.add_argument('-out', help='Path to dir where the smt is stored (by default, in ' + str(costabs_path) + ")",
                    nargs='?', default=costabs_path, metavar='dir')
    ap.add_argument('-write-only', help='print smt constraint in SMT-LIB format, '
                                                             'a mapping to instructions, and objectives',
                    action='store_true', dest='write_only')
    ap.add_argument('-at-most', help='add a constraint for each uninterpreted function so that they are used at most once',
                    action='store_true', dest='at_most')
    ap.add_argument('-pushed-once', help='add a constraint to indicate that each pushed value is pushed at least once',
                    action='store_true', dest='pushed_once')
    ap.add_argument("-solver", "--solver", help="Choose the solver", choices = ["z3","barcelogic","oms"], default="z3")
    ap.add_argument("-instruction-order", help='add a constraint representing the order among instructions',
                    action='store_true', dest='instruction_order')
    ap.add_argument("-no-output-before-pop", help='add a constraint representing the fact that the previous instruction'
                                                  'of a pop can only be a instruction that does not generate an output',
                    action='store_true', dest='no_output_before_pop')
    ap.add_argument("-tout", metavar='timeout', action='store', type=int, help="Timeout in seconds. "
                                                                               "Works only for z3 and oms (so far)")

    args = vars(ap.parse_args())
    json_path = args['json_path']
    path = args['out']
    solver = args['solver']
    timeout = args['tout']

    flags = {'at-most': args['at_most'], 'pushed-at-least': args['pushed_once'],
             'instruction-order': args['instruction_order'], 'no-output-before-pop': args['no_output_before_pop']}

    additional_info = {'tout': args['tout'], 'solver': solver}
    es = initialize_dir_and_streams(path,solver)

    b0, bs, user_instr, variables, initial_stack, final_stack = parse_data(json_path)
    generate_smtlib_encoding(b0, bs, user_instr, variables, initial_stack, final_stack, flags, additional_info)

    es.close()
